과 계 컴
오늘은 format!

*
go to 99999

~
이 구간은 점프
~

99999 continue !글자 수 최대가 5글자

**
read "(a, 3(f2.1, i1))", c, r1, j1, r2 ,j2, r3, j3
	!이는 a라는 옵션을 지키고, 각각의 변수에 f2.1, i1, f2.1, i1, f2.1, i1, f2.1, i1 형식이 배정된다. 이를 한번에 쓰기 위해 괄호 치고 3을 곱한 것처럼 디노트.
	!i1은 한자리 정수, f2.1은 두자리를 받아서 소숫점 하나를 의미한다. f2.1은 5.6 3글자를 받지 못하고, 5.6으로 표현하려면 f3.1을 사용해야 한다.

print "(a,3(f3.1,i1))", c, r1, j1, r2, j2, r3, j3
	! 위처럼 .이나 - 모두 하나의 글자로 취급하기 때문에, 5.6으로 할려면 f3.1로 자리를 할당해주어야 한다. 아니면 *이 뜬다.

print "(a, 2x, 3(f3.1,/,i1,/))"
	! 이제 각 문자에 f3.1 /와 i1 /가 적용된다. 2x는 두 칸을 띄운다는 뜻. /는 줄바꿈의 역할.

**
f8.2 형식은 8자리의 칸을 만들어 소숫점 아래 두자리까지 반올림해서 표시한다. 만일 123.789를 입력하면 __123.79 로 나타난다. f7.2는 _123.79, f6.2는 123.79
f5.2 는 123.79 최소 6자리가 필요하기 때문에 오류 출력(*****) 
f0.1 은 알아서 포맷 맞춰준다.

**
es 포맷 : 유효숫자
es8.1 은 8자리 할당해서 소숫점 몇자리까지 쓸지에 대한 말이다. 591.1의 경우 5.91E+02 각각 하나의 글자 차지. es0.1은 없다. 알아서 안맞춰준다.

**
i 포맷
-1000을 출력하려면 5자리가 필요하므로 i5 선언
i8.7 의 경우 8자리를 할당하는데 7자리는 반드시 사용해야 함을 의미한다. 9999를 넣는다면 _0009999 가 나온다.
(i4 i4) 9999 입력시 9999만 나온다. 형식 2개 출력 1개라면 뒤의 것을 무시해버린다.
(i4 i5) b3 b1 b2 는 b3는 i4, b1는 i5, b2는 i4 형식을 받는다. i4 i5가 순환하면서 분배된다.

**
2x는 출력할 때 띄어쓰기가 아니라 사실, 삼키는 기능을 한다.
(f3.1,2x,f3.1,2x,f3.1) 1234567890123 으로 받은 후 출력하면
1.2
6.7
	45가 씹힌다.

**
(a, 3(f3.1)) 에서 a는 본연의 문자 그대로를 받는다는 뜻이다.



8장 array
* matrix의 출력은 columnwise하게 이루어진다.
* 벡터의 인덱스를 새롭게 선언할 수 있다. 
REAL, DIMENSION(-2:3) a
	! 이렇게 쓰면, a(-2) a(-1) a(0) a(1) a(2) a(3) index가 -2로 시작하는 6차원 벡터를 생성한다.

* intrinsic function
ubound 는 upperbound, 1-dim과 2-dim의 마지막 index를 출력


**
array section

**
reshape
reshape((/1,2,3/),(/2,2/),(/0/),(2,1)
	!1 2 3이라는 원소를 2 by 2 matrix에 columnwise하게 넣을라고 했는데, 숫자가 모자라면 0을 pad로 채우고, 뒤에 옵션으로 (2,1)이 붙으면 순서를 rowwise하게 대입시켜라.

**
Array Constructors
(/(i,i=1,6)/) 이런 식으로도 vector 생성 가능

**
ALlocatable : 모양이 결정되지 않은 채로 두고 싶을 때 선언하는 것
ALLOCATE(A(-1:3,2:5),STAT=ierr) stat을 ierr에 대입. 만일 할당이 되었으면 T 아니면 F를 출력할 수 있다.

**
Masked Assignment
where 문을 이용해서 조건을 달 수 있다.
where(C/=0)
A=B/C
end where	!C가 0이 아닐 때만 저것을 연산하라.